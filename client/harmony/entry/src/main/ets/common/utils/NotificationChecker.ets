import common from '@ohos.app.ability.common';
import { NotificationService } from '../services/NotificationService';
import { CourseService } from '../services/CourseService';
import { StudyTaskService } from '../services/StudyTaskService';
import { NotificationSettings } from '../models/ApiModels';
import { Logger } from './Logger';

// é€šçŸ¥æ£€æŸ¥å™¨ - å®šæ—¶æ£€æŸ¥å¹¶è§¦å‘é€šçŸ¥
export class NotificationChecker {
  private static instance: NotificationChecker | null = null;
  private intervalId: number = -1;
  private settings: NotificationSettings = new NotificationSettings();
  private checkIntervalMs: number = 60000; // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
  private notifiedCourses: Set<string> = new Set(); // å·²é€šçŸ¥çš„è¯¾ç¨‹
  private notifiedTasks: Set<string> = new Set();   // å·²é€šçŸ¥çš„ä»»åŠ¡

  private constructor() {}

  static getInstance(): NotificationChecker {
    if (!NotificationChecker.instance) {
      NotificationChecker.instance = new NotificationChecker();
    }
    return NotificationChecker.instance;
  }

  // è·å–ä»Šå¤©çš„æ—¥æœŸ (YYYY-MM-DD)
  getTodayDate(): string {
    const now = new Date();
    const year = now.getFullYear();
    const month = (now.getMonth() + 1).toString().padStart(2, '0');
    const day = now.getDate().toString().padStart(2, '0');
    return `${year}-${month}-${day}`;
  }

  // è·å–ä»Šå¤©æ˜¯å‘¨å‡  (1-7)
  getTodayDayOfWeek(): number {
    const day = new Date().getDay();
    return day === 0 ? 7 : day;
  }

  // è·å–å½“å‰æ—¶é—´ (HH:mm)
  getCurrentTime(): string {
    const now = new Date();
    const hours = now.getHours().toString().padStart(2, '0');
    const minutes = now.getMinutes().toString().padStart(2, '0');
    return `${hours}:${minutes}`;
  }

  // æ—¶é—´å·®è®¡ç®— (åˆ†é’Ÿ)
  getTimeDiffMinutes(time1: string, time2: string): number {
    const [h1, m1] = time1.split(':').map(Number);
    const [h2, m2] = time2.split(':').map(Number);
    return (h1 * 60 + m1) - (h2 * 60 + m2);
  }

  // å¯åŠ¨æ£€æŸ¥å™¨
  async start(context: common.Context) {
    Logger.info('NotificationChecker: Starting...');
    await this.loadSettings(context);

    if (this.intervalId === -1) {
      this.intervalId = setInterval(() => {
        this.checkNotifications(context);
      }, this.checkIntervalMs);

      // ç«‹å³æ‰§è¡Œä¸€æ¬¡æ£€æŸ¥
      this.checkNotifications(context);
      Logger.info('NotificationChecker: Timer started');
    }
  }

  // åœæ­¢æ£€æŸ¥å™¨
  stop() {
    if (this.intervalId !== -1) {
      clearInterval(this.intervalId);
      this.intervalId = -1;
      Logger.info('NotificationChecker: Stopped');
    }
  }

  // æ¯å¤©é‡ç½®å·²é€šçŸ¥è®°å½•
  resetDailyNotifications() {
    this.notifiedCourses.clear();
    this.notifiedTasks.clear();
    Logger.info('NotificationChecker: Daily notifications reset');
  }

  // åŠ è½½é€šçŸ¥è®¾ç½®
  async loadSettings(context: common.Context) {
    try {
      const response = await NotificationService.getSettings(context);
      if (response.code === 200 && response.data) {
        this.settings = response.data;
        Logger.info('NotificationChecker: Settings loaded');
      }
    } catch (err) {
      Logger.error('NotificationChecker: Failed to load settings', JSON.stringify(err));
    }
  }

  // æ£€æŸ¥é€šçŸ¥
  private async checkNotifications(context: common.Context) {
    if (!this.settings.enabled) {
      return;
    }

    const now = this.getCurrentTime();
    const today = this.getTodayDate();
    const todayDayOfWeek = this.getTodayDayOfWeek();

    Logger.info(`NotificationChecker: Checking at ${now} on ${today} (day ${todayDayOfWeek})`);

    // æ£€æŸ¥è¯¾ç¨‹æé†’
    if (this.settings.courseReminder.enabled) {
      await this.checkCourseReminders(context, todayDayOfWeek, now);
    }

    // æ£€æŸ¥ä»»åŠ¡æé†’
    if (this.settings.assignmentReminder.enabled) {
      await this.checkTaskReminders(context, today, now);
    }
  }

  // æ£€æŸ¥è¯¾ç¨‹æé†’
  private async checkCourseReminders(context: common.Context, todayDayOfWeek: number, currentTime: string) {
    const minutesBefore = this.settings.courseReminder.minutesBefore || 15;

    try {
      const response = await CourseService.getWeekSchedule(context);
      if (response.code === 200 && response.data && response.data.schedule) {
        // æ‰¾åˆ°ä»Šå¤©çš„è¯¾ç¨‹
        const todaySchedule = response.data.schedule.find(d => d.dayOfWeek === todayDayOfWeek);
        if (todaySchedule && todaySchedule.timeSlots) {
          for (const slot of todaySchedule.timeSlots) {
            const courseKey = `${todayDayOfWeek}-${slot.startTime}-${slot.course.courseId}`;

            // è·³è¿‡å·²é€šçŸ¥çš„
            if (this.notifiedCourses.has(courseKey)) continue;

            // è®¡ç®—è·ä¸Šè¯¾æ—¶é—´å·®
            const diffMinutes = this.getTimeDiffMinutes(slot.startTime, currentTime);

            // åœ¨æŒ‡å®šæ—¶é—´èŒƒå›´å†…æé†’ (æå‰minutesBeforeåˆ°æå‰0åˆ†é’Ÿ)
            if (diffMinutes > 0 && diffMinutes <= minutesBefore) {
              this.notifiedCourses.add(courseKey);
              this.sendNotification(
                `ğŸ“š ${slot.course.courseName}`,
                `${diffMinutes}åˆ†é’Ÿåä¸Šè¯¾ï¼Œåœ°ç‚¹ï¼š${slot.course.location || 'æœªçŸ¥'}`
              );
              Logger.info(`NotificationChecker: Course reminder sent for ${slot.course.courseName}`);
            }
          }
        }
      }
    } catch (err) {
      Logger.error('NotificationChecker: Failed to check courses', JSON.stringify(err));
    }
  }

  // æ£€æŸ¥ä»»åŠ¡æé†’
  private async checkTaskReminders(context: common.Context, today: string, currentTime: string) {
    try {
      const response = await StudyTaskService.getStudyTasks(context, undefined, today);
      if (response.code === 200 && response.data && response.data.tasks) {
        for (const task of response.data.tasks) {
          const taskKey = `${task.taskId}-${task.startTime}`;

          // è·³è¿‡å·²å®Œæˆæˆ–å·²é€šçŸ¥çš„
          if (task.status === 'completed' || this.notifiedTasks.has(taskKey)) continue;

          // è®¡ç®—è·ä»»åŠ¡å¼€å§‹æ—¶é—´å·®
          const diffMinutes = this.getTimeDiffMinutes(task.startTime, currentTime);

          // æå‰15åˆ†é’Ÿæé†’ä»»åŠ¡
          if (diffMinutes > 0 && diffMinutes <= 15) {
            this.notifiedTasks.add(taskKey);
            this.sendNotification(
              `â° ${task.title}`,
              `${diffMinutes}åˆ†é’Ÿåå¼€å§‹`
            );
            Logger.info(`NotificationChecker: Task reminder sent for ${task.title}`);
          }
        }
      }
    } catch (err) {
      Logger.error('NotificationChecker: Failed to check tasks', JSON.stringify(err));
    }
  }

  // å‘é€æœ¬åœ°é€šçŸ¥
  private sendNotification(title: string, content: string) {
    Logger.info(`ğŸ”” NOTIFICATION: ${title} - ${content}`);

    // å®Œæ•´å®ç°éœ€è¦ä½¿ç”¨ @ohos.notificationManager API
    // import notificationManager from '@ohos.notificationManager';
    // const request: notificationManager.NotificationRequest = {
    //   id: Date.now(),
    //   content: {
    //     contentType: notificationManager.ContentType.NOTIFICATION_CONTENT_BASIC_TEXT,
    //     normal: { title: title, text: content }
    //   }
    // };
    // await notificationManager.publish(request);
  }
}
